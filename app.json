[{"name":"app.R","content":"source(\"R/namespace.R\")\n\nproblemset = list(\n  build_problemset(\n    list(\n      two_way_toy\n    ), \n    title = \"Unit A\"\n  ),\n  build_problemset(\n    list(\n      boot_mean_ci,\n      pval_ht,\n      bootstrap_mean_hist_ci,\n      randomization_mean_ht\n    ),\n    title = \"Unit B\"\n  ),\n  build_problemset(\n    list(\n      prop_ci,\n      prop_ht,\n      prop_ht_noscaf,\n      mean_ci,\n      mean_ht,\n      diffprop_ci,\n      diffprop_ht,\n      diffmean_ci,\n      diffmean_ht\n    ),\n    title = \"Unit C\"\n  ),\n  build_problemset(\n    list(\n      chi1d_equal\n    ),\n    title = \"Unit D\"\n  )\n)\n\n# Define UI for application that draws a histogram\nui <- make_ui(problemset)\n\nserver <- make_server(problemset)\n\n# Run the application \nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"R/calculation_practice.R","content":"# source(\"compile_problem.R\")\n# source(\"shiny_interface.R\")\n\ncalc_margin_simple = function(\n    center_mean=10, center_sd = 10, margin_df = 10, seed = NULL\n)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    center_mean, center_sd, margin_df, seed,\n    center = round(rnorm(1, mean = center_mean, sd = center_sd), 3),\n    margin = round(sqrt(rchisq(1, df=margin_df)), 3),\n    lb = round(center - margin, 3),\n    ub = round(center + margin, 3)\n  )\n  \n  question_template = r\"(The following expression defines the endpoints of an interval\n  $$\n  <<center>> \\pm <<margin>>.\n  $$)\"\n  subquestion_templates = list(\n    r\"(What is the value of the left endpoint?)\",\n    r\"(What is the value of the right endpoint?)\"\n  )\n  \n  answer = NULL\n  subanswers = with(setup, c(lb, ub))\n  \n  solution_template = NULL\n  subsolution_templates = list(\n    r\"(The left endpoint is $<<center>> - <<margin>> = <<lb>>$.)\",\n    r\"(The right endpoint is $<<center>> + <<margin>> = <<ub>>$.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    answer,\n    subanswers,\n    solution = compile_text(solution_template, setup),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\ncalc_margin_setup = function(center_mean=10, center_sd = 10, margin_df = 10) {\n  center = round(rnorm(1, mean = center_mean, sd = center_sd), 3)\n  margin = round(sqrt(rchisq(1, df=margin_df)), 3)\n  lb = center - margin\n  ub = center + margin\n  return(list(center=center, margin=margin, lb=lb, ub=ub))\n}\n\ncalc_margin_simple_template = list(\n  setup_fn = calc_margin_setup,\n  args = NULL,\n  question = r\"(\n  The following expression defines the endpoints of an interval\n  $$\n  <<center>> \\pm <<margin>>.\n  $$\n  )\",\n  solution = r\"()\",\n  subquestions = list(\n    r\"(What is the value of the left endpoint?)\",\n    r\"(What is the value of the right endpoint?)\"\n  ),\n  subanswers = list(\n    r\"(<<round(lb,3)>>)\",\n    r\"(<<round(ub,3)>>)\"\n  ),\n  subsolutions = list(\n    r\"(The left endpoint equals $<<center>> - <<margin>> = <<lb>>$.)\",\n    r\"(The right endpoint equals $<<center>> + <<margin>> = <<ub>>$.)\"\n  )\n)\n\ncalc_quadratic_setup = function() {\n  a = 1 + rgeom(1, prob = 0.5)\n  c = sample(c(-1,1), 1) * rgeom(1, prob = 0.125)\n  b = rgeom(1, prob = 0.125)\n  if (c > 0)\n    b = b + ceiling(2*sqrt(a*c))\n  b = b * sample(c(-1,1), 1)\n  xm = (-b - sqrt(b^2 - 4*a*c)) / (2*a)\n  xp = (-b + sqrt(b^2 - 4*a*c)) / (2*a)\n  return(list(a=a, b=b, c=c, xm=xm, xp=xp))\n}\n\ncalc_quadratic_plus_template = list(\n  setup_fn = calc_quadratic_setup,\n  args = NULL,\n  question = r\"(\n  Find the value of $x$ from the formula\n  $$\n  x = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}\n  $$\n  if $a=<<a>>$, $b=<<b>>$, and $c=<<c>>$.\n  )\",\n  answer = r\"(<<round(xp,3)>>)\",\n  solution = r\"(\n  In R, we can find the answer directly using \n  ```\n  (-<<wrapif(b)>> + sqrt(<<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>>)) / (2*<<a>>)\n  ```\n  which gives us $x = <<round(xp,3)>>$. Alternatively, we can assign variables\n  ```\n  a = <<a>>\n  b = <<b>>\n  c = <<c>>\n  ```\n  and use the formula\n  ```\n  (-b + sqrt(b^2 - 4*a*c)) / (2*a)\n  ```\n  which also gives us $x = <<round(xp,3)>>$.\n  )\"\n)\n\ncalc_quadratic_minus_template = list(\n  setup_fn = calc_quadratic_setup,\n  args = NULL,\n  question = r\"(\n  Find the value of $x$ from the formula\n  $$\n  x = \\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\n  $$\n  if $a=<<a>>$, $b=<<b>>$, and $c=<<c>>$.\n  )\",\n  answer = r\"(<<round(xm,3)>>)\",\n  solution = r\"(\n  In R, we can find the answer directly using \n  ```\n  (-<<wrapif(b)>> - sqrt(<<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>>)) / (2*<<a>>)\n  ```\n  which gives us $x = <<round(xm,3)>>$. Alternatively, we can assign variables\n  ```\n  a = <<a>>\n  b = <<b>>\n  c = <<c>>\n  ```\n  and use the formula\n  ```\n  (-b - sqrt(b^2 - 4*a*c)) / (2*a)\n  ```\n  which also gives us $x = <<round(xm,3)>>$.\n  )\"\n)\n\ncalc_quadratic_template = list(\n  setup_fn = calc_quadratic_setup,\n  args = NULL,\n  question = r\"(\n  Find the values of $x$ from the formula\n  $$\n  x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n  $$\n  if $a=<<a>>$, $b=<<b>>$, and $c=<<c>>$.\n  )\",\n  answer = NULL,\n  solution = NULL,\n  subquestions = list(\n    r\"(What is the value of $x$ if you use minus?)\",\n    r\"(What is the value of $x$ if you use plus?)\"\n  ),\n  subanswers = list(\n    r\"(<<round(xm,3)>>)\",\n    r\"(<<round(xp,3)>>)\"\n  ),\n  subsolutions = list(\n    r\"(\n    In R, we can find the answer directly using \n    \n    ```\n    (-<<wrapif(b)>> - sqrt(<<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>>)) / (2*<<a>>)\n    ```\n    \n    which gives us $x = <<round(xm,3)>>$. Alternatively, we can assign variables\n    \n    ```\n    a = <<a>>\n    b = <<b>>\n    c = <<c>>\n    ```\n    \n    and use the formula\n    \n    ```\n    (-b - sqrt(b^2 - 4*a*c)) / (2*a)\n    ```\n    \n    which also gives us $x = <<round(xm,3)>>$.\n    )\",\n    r\"(\n    Again, we can find the answer directly using \n    \n    ```\n    (-<<wrapif(b)>> + sqrt(<<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>>)) / (2*<<a>>)\n    ```\n    \n    which gives us $x = <<round(xp,3)>>$. Alternatively, we can use the variables above with the formula\n    \n    ```\n    (-b + sqrt(b^2 - 4*a*c)) / (2*a)\n    ```\n    \n    which also gives us $x = <<round(xp,3)>>$.\n    )\"\n  )\n)\n\ncalc_quadratic = function(seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    a = 1 + rgeom(1, prob = 0.5),\n    c = sample(c(-1,1), 1) * rgeom(1, prob = 0.125),\n    b = sample(c(-1,1), 1) * rgeom(1, prob = 0.125),\n    discr = b^2 - 4*a*c,\n    xm = ifelse(discr >= 0, (-b - sqrt(b^2 - 4*a*c)) / (2*a), NaN),\n    xp = ifelse(discr >= 0, (-b + sqrt(b^2 - 4*a*c)) / (2*a), NaN)\n  )\n  \n  question_template = r\"(Find the values of $x$ from the formula\n  $$\n  x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n  $$\n  if $a=<<a>>$, $b=<<b>>$, and $c=<<c>>$.\n  )\"\n  subquestion_templates = list(\n    r\"(What is the value of $x$ if you use minus?)\",\n    r\"(What is the value of $x$ if you use plus?)\"\n  )\n  answer = NULL\n  subanswers = with(setup, c(xm, xp))\n  solution_template = NULL\n  if (setup$discr >= 0) {\n    subsolution_templates = list(\n      r\"(In R, we can find the answer directly using \n    \n    ```\n    (-<<wrapif(b)>> - sqrt(<<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>>)) / (2*<<a>>)\n    ```\n    \n    which gives us $x = <<round(xm,3)>>$. Alternatively, we can assign variables\n    \n    ```\n    a = <<a>>\n    b = <<b>>\n    c = <<c>>\n    ```\n    \n    and use the formula\n    \n    ```\n    (-b - sqrt(b^2 - 4*a*c)) / (2*a)\n    ```\n    \n    which also gives us $x = <<round(xm,3)>>$.\n    )\",\n    r\"(\n    Again, we can find the answer directly using \n    \n    ```\n    (-<<wrapif(b)>> + sqrt(<<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>>)) / (2*<<a>>)\n    ```\n    \n    which gives us $x = <<round(xp,3)>>$. Alternatively, we can use the variables above with the formula\n    \n    ```\n    (-b + sqrt(b^2 - 4*a*c)) / (2*a)\n    ```\n    \n    which also gives us $x = <<round(xp,3)>>$.\n    )\"\n    )\n  } else {\n    subsolution_templates = list(\n      r\"(Ordinarily, we could find the answer using \n    \n    ```\n    (-<<wrapif(b)>> - sqrt(<<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>>)) / (2*<<a>>)\n    ```\n    \n    but in this problem <<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>> (called the discriminant) is negative, so there are no real solutions.)\",\n      r\"(Again, we could ordinarily find the answer using \n    ```\n    (-<<wrapif(b)>> + sqrt(<<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>>)) / (2*<<a>>)\n    ```\n    \n    but the discriminant <<wrapif(b)>>^2 - 4*<<a>>*<<wrapif(c)>> is negative, so there are no real solutions.)\"\n    )\n  }\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    answer,\n    subanswers,\n    solution = compile_text(solution_template, setup),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\n\n\n","type":"text"},{"name":"R/compile_problem.R","content":"# require(tidyverse)\n# require(glue)\n# require(withr)\n# require(magrittr)\n\ncompile_text = function(text, vars=parent.frame()) {\n  return(glue(text, .envir = vars, .open = \"<<\", .close = \">>\"))\n}\n\ncompile_figure = function(func, vars) {\n  return(function() {func(vars)})\n}\n\ncompile_problem = function(\n    setup,\n    question_template = NULL,\n    subquestion_templates = NULL,\n    figures = NULL,\n    tables = NULL,\n    answer = NULL,\n    subanswers = NULL,\n    solution_template = NULL,\n    subsolution_templates = NULL,\n    sol_figures = NULL,\n    sol_tables = NULL\n) {\n  lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    figures,\n    tables,\n    solution = compile_text(solution_template, setup),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)}),\n    sol_figures,\n    sol_tables,\n  )\n}\n\ncompile_problem_old = function(template) {\n  if (is.null(template$args)) {\n    vars = template$setup_fn()\n  } else {\n    vars = do.call(template$setup_fn, template$args)\n  }\n  \n  result = list(\n    question = template$question %>% compile_text(vars),\n    answer = template$answer %>% compile_text(vars),\n    solution = template$solution %>% compile_text(vars)\n  )\n  \n  if (!is.null(template$figures)) {\n    result$figures = sapply(template$figures, function(x) {compile_figure(x, vars)})\n  }\n  if (!is.null(template$sol_figures)) {\n    result$sol_figures = sapply(template$sol_figures, function(x) {compile_figure(x, vars)})\n  }\n  \n  if (!is.null(template$subquestions)) {\n    result$subquestions = sapply(template$subquestions, function(x) {compile_text(x, vars)})\n  }\n  if (!is.null(template$subanswers)) {\n    result$subanswers = sapply(template$subanswers, function(x) {compile_text(x, vars)})\n  }\n  if (!is.null(template$subsolutions)) {\n    result$subsolutions = sapply(template$subsolutions, function(x) {compile_text(x, vars)})\n  }\n  return(result)\n}\n\nsample_problem = function(problemset) {\n  template = sample(problemset$template_list, 1, prob=problemset$prob)[[1]]\n  result = template()\n  return(result)\n}\n\n# sample_problems = function(problemset, size, replace=FALSE) {\n#   templates = sample(problemset$template_list, size = size, replace = replace, prob=problemset$prob)\n#   result = lapply(templates, compile_problem)\n#   return(result)\n# }\n\nbuild_problemset = function(template_list, prob=NULL, title=\"\", label=title) {\n  if (!is.null(prob) && length(prob) != length(template_list))\n    stop(\"Incorrect number of probabilities\")\n  # if (is.null(label))\n  #   label = title\n  list(template_list = template_list, prob = prob, title = title, label = label)\n}\n\nall_questions = function(problem, listch = '1', prepend_question=TRUE, spacer=\"\") {\n  formatted_subquestions = lapply(\n    problem$subquestions,\n    function(sq) {\n      sq = str_replace_all(sq, \"\\n\", \"\\n    \")\n      glue(\"{listch}. {sq}\\n{spacer}\")\n    }\n  )\n  \n  if (prepend_question) {\n    formatted_subquestions = c(problem$question, formatted_subquestions)\n  }\n  \n  result = paste0(formatted_subquestions, collapse = \"\\n\\n\")\n  return(result)\n}\n\nall_solutions = function(problem, listch = '1', prepend_solution=TRUE) {\n  formatted_subsolutions = lapply(\n    problem$subsolutions,\n    function(sq) {\n      sq = str_replace_all(sq, \"\\n\", \"\\n    \")\n      glue(\"{listch}. {sq}\")\n    }\n  )\n  \n  if (prepend_solution) {\n    formatted_subsolutions = c(problem$solution, formatted_subsolutions)\n  }\n  \n  result = paste0(formatted_subsolutions, collapse = \"\\n\\n\")\n  return(result)\n}\n\nformat_problem = function(prob, pts=NULL, spacer=\"\") {\n  for (fig_fn in prob$figures) {\n    fig_fn()\n  }\n  for (table in prob$tables) {\n    print(knitr::kable(table))\n  }\n  if (is.null(pts)) {\n    cat(all_questions(prob, spacer = spacer))\n  } else {\n    cat(glue(\"({pts} points) \"), all_questions(prob, spacer = spacer))\n  }\n}\n\nformat_solution = function(prob) {\n  for (fig_fn in prob$sol_figures) {\n    fig_fn()\n  }\n  for (table in prob$sol_tables) {\n    print(knitr::kable(table))\n  }\n  cat(all_solutions(prob))\n}\n\nformat_problems = function(probs, pts_list=NULL, show_sol=FALSE) {\n  for (i in seq_along(probs)) {\n    prob = probs[[i]]\n    cat(glue(\"## Problem {i}\\n\\n\"))\n    if (is.null(pts_list)) {\n      pts = NULL\n    } else if (length(pts_list) == 1) {\n      pts = pts_list[1]\n    } else {\n      pts = pts_list[i]\n    }\n    format_problem(prob, pts)\n    if (show_sol) {\n      cat(\"\\n\\n***\\n\\n### Solution\\n\\n\")\n      format_solution(prob)\n    }\n    cat(\"\\n\\n\",r\"(\\newpage)\",\"\\n\\n\")\n  }\n}\n\n","type":"text"},{"name":"R/namespace.R","content":"require(tidyverse)\nrequire(glue)\nrequire(withr)\nrequire(magrittr)\n\nwith_dir(\n  \"R\",\n  {\n    source(\"compile_problem.R\")\n    source(\"question_helpers.R\")\n    source(\"shiny_interface.R\")\n    # source(\"latex_exam_interface.R\")\n    \n    source(\"prop_practice.R\")\n    source(\"calculation_practice.R\")\n    source(\"unit_a.R\")\n    source(\"unit_b.R\")\n    source(\"unit_c.R\")\n    source(\"unit_d.R\")\n    # source(\"shiny_examples.R\")\n  }\n)\n\n","type":"text"},{"name":"R/prop_practice.R","content":"# source(\"compile_problem.R\")\n# source(\"shiny_interface.R\")\n\nsimple_prop_setup_old = function(avg_tot=30, avg_prop=0.5, tuning=10) {\n  lst(\n    total = rpois(n = 1, lambda = avg_tot),\n    target_prop = rbeta(n = 1, shape1 = avg_prop*tuning, shape2 = (1-avg_prop)*tuning),\n    successes = rbinom(n = 1, size = total, prob = target_prop),\n    failures = total - successes,\n    proportion = round(successes / total, 3)\n  )\n}\n\nsimple_prop_setup = function(avg_tot=30) {\n  lst(\n    total = rpois(n = 1, lambda = avg_tot),\n    successes = sample.int(n=total, size=1),\n    failures = total - successes,\n    proportion = round(successes / total, 3)\n  )\n}\n\n\npet_prop = function(seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = simple_prop_setup()\n  \n  question_template = r\"(In a survey of <<total>> people, <<successes>> people said they had a pet. What proportion of the people had a pet?)\"\n  answer = with(setup, proportion)\n  solution_template = r\"(The proportion of people with a pet is $\\frac{<<successes>>}{<<total>>} = <<round(proportion, 3)>>$.)\"\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    answer,\n    solution = compile_text(solution_template, setup)\n  ))\n}\n\npet_prop_template = list(\n  setup_fn = simple_prop_setup,\n  args = NULL,\n  question = \"In a survey of <<total>> people, <<successes>> people said they had a pet.\n  \n  What proportion of the people had a pet?\",\n  answer = \"<<proportion>>\",\n  solution = r\"(The proportion of people with a pet is $\\frac{<<successes>>}{<<total>>} = <<round(proportion, 3)>>$.)\"\n)\n\nsimple_prop = function(seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = simple_prop_setup()\n  \n  question_template = r\"(In a survey of <<total>> people, <<successes>> people said \"yes\" to a particular question. What proportion of the people said \"yes\"?)\"\n  answer = with(setup, proportion)\n  solution_template = r\"(The proportion is $\\frac{<<successes>>}{<<total>>} = <<round(proportion, 3)>>$.)\"\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    answer,\n    solution = compile_text(solution_template, setup)\n  ))\n}\n\nsimple_prop_template = list(\n  setup_fn = simple_prop_setup,\n  args = NULL,\n  question = r\"(In a survey of <<total>> people, <<successes>> people said \"yes\" to a particular question.\n  \n  What proportion of the people said \"yes\"?)\",\n  answer = \"<<proportion>>\",\n  solution = r\"(The proportion is $\\frac{<<successes>>}{<<total>>} = <<round(proportion, 3)>>$.)\"\n)\n\nsimple_percent = function(seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = simple_prop_setup()\n  \n  question_template = r\"(In a survey of <<total>> people, <<successes>> people said \"yes\" to a particular question. What percent of the people said \"yes\"?)\"\n  answer = with(setup, proportion*100)\n  solution_template = r\"(The percentage is $\\frac{<<successes>>}{<<total>>}\\cdot 100\\% = <<round(proportion*100, 1)>>\\%$.)\"\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    answer,\n    solution = compile_text(solution_template, setup)\n  ))\n}\n\nsimple_percent_template = list(\n  setup_fn = simple_prop_setup,\n  args = NULL,\n  question = r\"(In a survey of <<total>> people, <<successes>> people said \"yes\" to a particular question.\n  \n  What percent of the people said \"yes\"?)\",\n  answer = r\"(<<proportion*100>>\\%)\",\n  solution = r\"(The percentage is $\\frac{<<successes>>}{<<total>>}\\cdot 100\\% = <<round(proportion*100, 1)>>\\%$.)\"\n)\n\nsimple_successes = function(seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = simple_prop_setup()\n  \n  question_template = r\"(In a survey of <<total>> people, the proportion of the people who said \"yes\" to a particular question was <<proportion>>. How many of the people said \"yes\"?)\"\n  answer = with(setup, successes)\n  solution_template = r\"(The number of people who said \"yes\" is $<<total>> \\cdot <<proportion>> = <<successes>>$.)\"\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    answer,\n    solution = compile_text(solution_template, setup)\n  ))\n}\n\nsimple_successes_template = list(\n  setup_fn = simple_prop_setup,\n  args = NULL,\n  question = r\"(In a survey of <<total>> people, the proportion of the people said \"yes\" to a particular question was <<round(proportion, 3)>>.\n  \n  How many of the people said \"yes\"?)\",\n  answer = r\"(<<successes>>)\",\n  solution = r\"(The number of people who said \"yes\" is $<<total>> \\cdot <<round(proportion, 3)>> = <<successes>>$.)\"\n)\n\nsimple_percent_successes = function(seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = simple_prop_setup()\n  \n  question_template = r\"(In a survey of <<total>> people, <<round(proportion*100, 1)>>% of the people said \"yes\" to a particular question. How many of the people said \"yes\"?)\"\n  answer = with(setup, successes)\n  solution_template = r\"(The number of people who said \"yes\" is $<<total>> \\cdot <<proportion>> = <<successes>>$.)\"\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    answer,\n    solution = compile_text(solution_template, setup)\n  ))\n}\n\nsimple_percent_successes_template = list(\n  setup_fn = simple_prop_setup,\n  args = NULL,\n  question = r\"(In a survey of <<total>> people, <<round(proportion*100, 1)>>% of the people said \"yes\" to a particular question.\n  \n  How many of the people said \"yes\"?)\",\n  answer = r\"(<<successes>>)\",\n  solution = r\"(The number of people who said \"yes\" is $<<total>> \\cdot <<round(proportion, 3)>> = <<successes>>$.)\"\n)\n\ndotplot_visual_prop_setup = function() {\n  lst(\n    n_samps = rpois(1, 13)+2,\n    mu = 20,\n    s = 2,\n    samp = rnorm(n = n_samps, mean = mu, sd = s),\n    breaks = seq(round(min(samp)/0.5)*0.5-0.5, round(max(samp)/0.5)*0.5+0.5, by = 0.5),\n    cutoff = sample(breaks, 1),\n    gtlt = sample(c(\">\", \"<\"), 1),\n    successes = ifelse(gtlt == \">\", sum(samp > cutoff), sum(samp < cutoff)),\n    proportion = round(successes / n_samps, 3)\n  )\n}\n\ndotplot_visual_prop_fig = function(setup) {\n  hist_out = hist(setup$samp, breaks = setup$breaks, plot=FALSE)\n  par(mar = c(3, 4, 1, 1)+0.1)\n  hist_to_dotplot(hist_out, pch=19, xlab=\"\")\n  abline(v=setup$cutoff, col=\"black\", lty=2)\n}\n\ndotplot_visual_prop_solfig = function(setup) {\n  hist_out = hist(setup$samp, breaks = setup$breaks, plot=FALSE)\n  par(mar = c(3, 4, 1, 1)+0.1)\n  stacks = hist_to_stacks(hist_out)\n  mask = stacks$x > setup$cutoff\n  if (setup$gtlt == \"<\")\n    mask = !mask\n  col_mask = ifelse(mask, \"red\", \"black\")\n  hist_to_dotplot(hist_out, pch=19, xlab=\"\", col=col_mask)\n  abline(v=setup$cutoff, col=\"black\", lty=2)\n}\n\ndotplot_visual_prop = function(seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = dotplot_visual_prop_setup()\n  \n  question_template = r\"(What proportion of the <<n_samps>> points shown are <<greater_less(gtlt)>> than <<cutoff>> (dashed line)?)\"\n  answer = with(setup, proportion)\n  solution_template = r\"(We see that <<successes>> of the points (colored red here) are <<greater_less(gtlt)>> than <<cutoff>>, so the proportion is $\\frac{<<successes>>}{<<n_samps>>} = <<proportion>>$.)\"\n  figure_templates = list(\n    dotplot_visual_prop_fig\n  )\n  sol_figure_templates = list(\n    dotplot_visual_prop_solfig\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    answer,\n    solution = compile_text(solution_template, setup),\n    figures = sapply(figure_templates, function(x) {compile_figure(x, setup)}),\n    sol_figures = sapply(sol_figure_templates, function(x) {compile_figure(x, setup)})\n  ))\n}\n\n\ndotplot_visual_prop_template = list(\n  setup_fn = dotplot_visual_prop_setup,\n  args = NULL,\n  question = r\"(What proportion of the <<n_samps>> points shown are <<greater_less(gtlt)>> than <<cutoff>> (dashed line)?)\",\n  answer = \"<<round(proportion, 3)>>\",\n  solution = r\"(We see that <<successes>> of the points (colored red here) are <<greater_less(gtlt)>> than <<cutoff>>, so the proportion is $\\frac{<<successes>>}{<<n_samps>>} = <<round(proportion, 3)>>$.)\",\n  figures = list(\n    dotplot_visual_prop_fig\n  ),\n  sol_figures = list(\n    dotplot_visual_prop_solfig\n  )\n)\n\nproportion_template_list = list(\n  simple_prop,\n  dotplot_visual_prop\n)\n\nproportion_problemset = build_problemset(\n  template_list=proportion_template_list, \n  title=\"Calculating a Proportion\", \n  label=\"Proportions\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"text"},{"name":"R/question_helpers.R","content":"# require(tidyverse)\n# require(glue)\n# require(withr)\n# require(magrittr)\n\nNEQ = r\"(\\neq)\"\n\nvspace = function(v) {\n  compile_text(r\"(\\vspace{<<v>>})\")\n}\n\nis_neg = function(x) {\n  as.numeric(x) < 0\n}\n\nwrapif = function(x, cond = is_neg, left = '(', right = ')') {\n  if (cond(x)) {\n    return(paste0(left, x, right))\n  }\n  return(x)\n}\n\ngreater_less = function(gtlt, capitalize=FALSE) {\n  if (!(gtlt %in% c(\">\", \"<\")))\n    stop(\"Argument gtlt not one of '>' or '<'.\")\n  if (gtlt == \">\") {\n    result = \"greater\"\n  } else {\n    result = \"less\"\n  }\n  if (capitalize)\n    result = str_to_title(result)\n  return(result)\n}\n\ncomma_and = function(x, oxford = TRUE) {\n  last = if (oxford) {\", and \"} else {\" and \"}\n  return(glue_collapse(x, sep = \", \", last = last))\n}\n\n\nindep_tab = function(n, rprobs, cprobs, dnames=NULL, totals=TRUE) {\n  pvec = as.vector(rprobs %o% cprobs)\n  counts = as.integer(stats::rmultinom(n=1, size=n, prob=pvec))\n  dim(counts) = c(length(rprobs), length(cprobs))\n  \n  if (!is.null(dnames)) {\n    dimnames(counts) = dnames\n  }\n  \n  if (totals) {\n    omat = addmargins(counts, FUN = list(Total = sum), quiet = TRUE)\n  } else {\n    omat = counts\n  }\n  \n  mode(omat) = \"integer\"\n  \n  return(omat)\n}\n\nlgd = function(ineq) {\n  result = \"different\"\n  if (ineq == \"<\") {\n    result = \"less\"\n  } else if (ineq == \">\") {\n    result = \"greater\"\n  }\n  return(result)\n}\n\ncomp = function(a, b) {\n  case_when(\n    a == b ~ \"=\",\n    a > b ~ \">\",\n    a < b ~ \"<\"\n  )\n}\n\nz_ineq_pval = function(z, ineq) {\n  if (ineq == \"<\") {\n    pval = pnorm(z, lower.tail = TRUE)\n  } else if (ineq == \">\") {\n    pval = pnorm(z, lower.tail = FALSE)\n  } else {\n    pval = 2*pnorm(abs(z), lower.tail = FALSE)\n  }\n  return(pval)\n}\n\nt_ineq_pval = function(t, df, ineq) {\n  if (ineq == \"<\") {\n    pval = pt(t, df=df, lower.tail = TRUE)\n  } else if (ineq == \">\") {\n    pval = pt(t, df=df, lower.tail = FALSE)\n  } else {\n    pval = 2*pt(abs(t), df=df, lower.tail = FALSE)\n  }\n  return(pval)\n}\n\n\nlower_tail = function(ineq, z) {\n  ((ineq == \"<\") || (ineq == NEQ && z < 0))\n}\n\n\nenum_stack = function(x, count) {\n  data.frame(x = rep(x, count), Count = 1:count)\n}\n\nhist_to_stacks = function(hist_out) {\n  result = NULL\n  for (index in seq_along(hist_out$mids)) {\n    if (hist_out$counts[index] > 0) {\n      result = rbind(result, enum_stack(hist_out$mids[index], hist_out$counts[index]))\n    }\n  }\n  return(result)\n}\n\nhist_to_dotplot = function(hist_out, xlim=NULL, ylim=NULL, ...) {\n  stacks = hist_to_stacks(hist_out)\n  if (is.null(xlim)) {\n    xlim = range(hist_out$breaks)\n  }\n  if (is.null(ylim)) {\n    ylim = c(0, max(hist_out$counts)+1)\n  }\n  plot(stacks, xlim=xlim, ylim=ylim, ...)\n}\n\ndotplot = function(x, breaks=\"Sturges\", xlim=NULL, ylim=NULL, plot=TRUE, xlab=NULL, ylab=\"Count\", ...) {\n  hist_out = hist(x, breaks=breaks, plot=FALSE)\n  stacks = hist_to_stacks(hist_out)\n  if (is.null(xlim)) {\n    xlim = range(hist_out$breaks)\n  }\n  if (is.null(ylim)) {\n    ylim = c(0, max(hist_out$counts)+1)\n  }\n  if (is.null(xlab)) {\n    xlab = hist_out$xname\n  }\n  if (plot) {\n    plot(stacks, xlim=xlim, ylim=ylim, xlab=xlab, ylab=ylab, ...)\n  }\n  result = lst(!!!hist_out, stacks)\n  return(result)\n}\n\nrdist = function(k, concentration=1) {\n  raw = rgamma(n=k, shape=concentration)\n  return(raw/sum(raw))\n}\n\npoints_block = function(pts) {\n  total = sum(pts)\n  qnums = as.character(1:length(pts))\n  pts_tib = tibble(\"Question\" = c(qnums, \"Total\"), \"Points Possible\" = c(pts, total), \"Points Received\" = \"\")\n  knitr::kable(pts_tib, align = 'c')\n}\n\n\n\n\n\n","type":"text"},{"name":"R/shiny_interface.R","content":"require(shiny)\nrequire(glue)\nrequire(markdown)\n\n\nproblemUI = function(id, title=\"Problem\") {\n  ns = NS(id)\n  \n  tagList(\n    withMathJax(),\n    # section below allows in-line LaTeX via $ in mathjax.\n    # rmdMathJax(),\n    \n    sidebarLayout(\n      sidebarPanel(\n        actionButton(ns(\"new_problem\"), \"New Problem\"),\n        checkboxInput(ns(\"show_solution\"), \"Show Solution\", FALSE)\n      ),\n      \n      mainPanel(\n        # h3(title),\n        h3(\"Problem\"),\n        uiOutput(ns(\"figs\")),\n        uiOutput(ns(\"tables\")),\n        htmlOutput(ns(\"prob\")),\n        conditionalPanel(\n          \"input.show_solution == true\",\n          ns=ns,\n          hr(),\n          h3(\"Solution\"),\n          uiOutput(ns(\"solfigs\")),\n          uiOutput(ns(\"soltables\")),\n          htmlOutput(ns(\"sol\"))\n        )\n      )\n    )\n  )\n}\n\nproblemServer = function(id, problemset) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      observe({\n        updateCheckboxInput(session, \"show_solution\", value = FALSE)\n      }) %>% bindEvent(input$new_problem)\n      \n      problem <- reactive({\n        sample_problem(problemset)\n      }) %>% bindEvent(input$new_problem, ignoreNULL = FALSE)\n      \n      observe({\n        pr = problem()\n        \n        for (index in seq_along(pr$figures)) {\n          output[[glue(\"figure{index}\")]] = renderPlot({\n            pr$figures[[index]]()\n          })\n        }\n        \n        for (index2 in seq_along(pr$tables)) {\n          output[[glue(\"table{index2}\")]] = renderTable(\n            pr$tables[[index2]], rownames = TRUE\n          )\n        }\n        \n        for (index3 in seq_along(pr$sol_figures)) {\n          output[[glue(\"sol_figure{index3}\")]] = renderPlot({\n            pr$sol_figures[[index3]]()\n          })\n        }\n        \n        for (index4 in seq_along(pr$sol_tables)) {\n          output[[glue(\"sol_table{index4}\")]] = renderTable(\n            pr$sol_tables[[index4]], rownames = TRUE\n          )\n        }\n      })\n      \n      output$figs <- renderUI({\n        ns <- session$ns\n        pr = problem()\n        if (!(length(pr$figures) > 0)) return()\n        \n        plot_output_list = lapply(seq_along(pr$figures), function(index) {\n          plotOutput(ns(glue(\"figure{index}\")))#, height = '250px')\n        })\n        \n        do.call(fluidRow, plot_output_list)\n      })\n      \n      output$tables <- renderUI({\n        ns <- session$ns\n        pr = problem()\n        # if (!(length(pr$tables) > 0)) return()\n        \n        tab_output_list = lapply(seq_along(pr$tables), function(index) {\n          tableOutput(ns(glue(\"table{index}\")))\n        })\n        \n        do.call(fluidRow, tab_output_list)\n      })\n      \n      output$prob <- renderUI({\n        pr = problem()\n        withMathJax(\n          # HTML(markdown_html(all_questions(pr)))\n          HTML(mark_html(text=all_questions(pr), options = \"-standalone\"))\n        )\n      })\n      \n      output$solfigs <- renderUI({\n        ns <- session$ns\n        pr = problem()\n        if (!(length(pr$sol_figures) > 0)) return()\n        \n        plot_output_list = lapply(1:length(pr$sol_figures), function(index) {\n          plotOutput(ns(glue(\"sol_figure{index}\")))#, height = '250px')\n        })\n        \n        do.call(fluidRow, plot_output_list)\n      })\n      \n      output$soltables <- renderUI({\n        ns <- session$ns\n        pr = problem()\n        # if (!(length(pr$sol_tables) > 0)) return()\n        \n        tab_output_list = lapply(seq_along(pr$sol_tables), function(index) {\n          tableOutput(ns(glue(\"sol_table{index}\")))\n        })\n        \n        do.call(fluidRow, tab_output_list)\n      })\n      \n      output$sol <- renderUI({\n        # if (!input$show_solution) return()\n        pr = problem()\n        withMathJax(\n          # HTML(markdown_html(all_solutions(pr)))\n          HTML(mark_html(text=all_solutions(pr), options = \"-standalone\"))\n        )\n      })\n    }\n  )\n}\n\n\nmake_ui = function(problemset_list, title=\"Practice\") {\n  ui <- do.call(\n    navbarPage, \n    c(title=title,\n      lapply(\n        1:length(problemset_list),\n        function(index) {\n          tabPanel(\n            title = problemset_list[[index]]$label,\n            problemUI(\n              id=glue(\"tab{index}\"), \n              title = problemset_list[[index]]$title\n            )\n          )\n        }\n      )\n    )\n  )\n  return(ui)\n}\n\nmake_server = function(problemset_list, title=\"Practice\") {\n  server <- function(input, output, session) {\n    lapply(\n      X=1:length(problemset_list),\n      FUN=function(index) {\n        problemServer(\n          id = glue(\"tab{index}\"),\n          problemset = problemset_list[[index]]\n        )\n      }\n    )\n  }\n  return(server)\n}\n\n\n","type":"text"},{"name":"R/unit_a.R","content":"# source(\"compile_problem.R\")\n# source(\"question_helpers.R\")\n\n\ntwo_way_toy = function(\n    n = 1000, \n    row_probs = c(0.4, 0.6), \n    col_probs = c(0.2, 0.5, 0.3),\n    seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    # Problem setup\n    n, row_probs, col_probs, seed,\n    row_names = c(\"Adult\", \"Child\"),\n    col_names = c(\"A\", \"B\", \"C\"),\n    q_brands = sample(col_names),\n    dim_names = list(Adult = row_names, Brand = col_names),\n    twtab = indep_tab(\n      n=n, rprobs = row_probs, cprobs = col_probs, \n      dnames = dim_names, totals = TRUE\n    ),\n    # Solution steps\n    q1_num = round(twtab[\"Child\",\"Total\"]),\n    q1_den = round(twtab[\"Total\",\"Total\"]),\n    q1_ans = round(q1_num / q1_den, 3),\n    q2_num = round(twtab[\"Child\",q_brands[1]]),\n    q2_den = round(twtab[\"Child\",\"Total\"]),\n    q2_ans = round(q2_num / q2_den, 3),\n    q3_num = round(twtab[\"Adult\", q_brands[2]]),\n    q3_den = round(twtab[\"Total\", q_brands[2]]),\n    q3_ans = round(q3_num / q3_den, 3),\n    q4_num1 = round(twtab[\"Adult\", q_brands[3]]),\n    q4_den1 = round(twtab[\"Adult\", \"Total\"]),\n    q4_ans1 = round(q4_num1 / q4_den1, 3),\n    q4_num2 = round(twtab[\"Child\", q_brands[3]]),\n    q4_den2 = round(twtab[\"Child\", \"Total\"]),\n    q4_ans2 = round(q4_num2 / q4_den2, 3),\n    q4_ans = round(q4_ans1 - q4_ans2, 3)\n  )\n  \n  question_template = r\"(Toy company researchers performed a survey of <<n>> adults and children, asking them to pick their favorite toy company brand (A, B, or C). The results are summarized in the table.)\"\n  subquestion_templates = list(\n    r\"(What proportion of participants were children?)\",\n    r\"(What proportion of children prefer brand <<q_brands[1]>>?)\",\n    r\"(What proportion of participants who prefer brand <<q_brands[2]>> were adults?)\",\n    r\"(What is the difference between the proportion of adults who prefer brand <<q_brands[3]>> and the proportion of children who prefer brand <<q_brands[3]>>?)\"\n  )\n  \n  answer = NULL\n  subanswers = with(setup, c(q1_ans, q2_ans, q3_ans, q4_ans))\n  \n  solution_template = NULL\n  subsolution_templates = list(\n    r\"($<<q1_num>> / <<q1_den>> = <<q1_ans>>$)\",\n    r\"($<<q2_num>> / <<q2_den>> = <<q2_ans>>$)\",\n    r\"($<<q3_num>> / <<q3_den>> = <<q3_ans>>$)\",\n    r\"($<<q4_num1>> / <<q4_den1>> - <<q4_num2>> / <<q4_den2>> = <<q4_ans1>> - <<q4_ans2>> = <<q4_ans>>$)\"\n  )\n  \n  tables = with(setup, list(twtab))\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    answer,\n    subanswers,\n    solution = compile_text(solution_template, setup),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)}),\n    tables\n  ))\n}\n\n","type":"text"},{"name":"R/unit_b.R","content":"# source(\"compile_problem.R\")\n# source(\"question_helpers.R\")\n\n\nmeans_topics = tribble(\n  ~topic, ~cases, ~units, ~mu, ~sigma, ~nulls,\n  \"diameter of trees in Yellowstone National Park\", \"trees\", \"inches\", 38, 10, 34:42,\n  \"diameter of trees in Acadia National Park\", \"trees\", \"inches\", 29, 10, 25:35,\n  \"age of visitors to Rouge Raisin winery\", \"visitors\", \"years\", 45, 10, 40:50,\n  \"length of gribbles\", \"gribbles\", \"mm\", 5.3, 2, seq(5.0, 6.0, by=0.1),\n  \"human body temperature\", \"people\", \"degrees F\", 98.26, 0.765, c(98.2, 98.6)\n)\n\n\nboot_mean_ci = function(topics = means_topics, seed = NULL) {\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    seed,\n    !!!slice_sample(topics, n=1),\n    sqrtn = sample(c(2, 5, 10, 20, 50), size=1),\n    se = round(sigma/sqrtn, 2),\n    xbar = round(rnorm(n=1, mean=mu, sd=se), 1),\n    # Solution steps\n    lb = round(xbar - 2*se, 3),\n    ub = round(xbar + 2*se, 3)\n  )\n  \n  question_template = r\"(Estimating <<topic>>, you observe that your sample mean is <<xbar>> and the standard deviation of your bootstrap distribution is <<se>>.)\"\n  subquestion_templates = list(\n    r\"(Identify the parameter of interest both in words and in symbol(s).)\",\n    r\"(Using the 95% rule, calculate a 95% confidence interval for your parameter.)\",\n    r\"(Interpret your confidence interval in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(We are estimating $\\mu$, the average <<topic>>.)\",\n    r\"(Using the 95% rule, the 95% confidence interval is $\\bar{x} \\pm 2(SE) = (<<lb>>, <<ub>>)$\n    - Lower bound: $<<xbar>> - 2(<<se>>) = <<lb>>$\n    - Upper bound: $<<xbar>> + 2(<<se>>) = <<ub>>$)\",\n    r\"(We are 95% confident that the average <<topic>> is between <<lb>> and <<ub>> <<units>>.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\nht_topics = tribble(\n  ~topic, ~null, ~alt,\n  \"the correlation between item price and number of items sold is negative\", r\"(\\rho = 0)\", r\"(\\rho < 0)\",\n  \"there is a correlation between item price and number of items sold\", r\"(\\rho = 0)\", r\"(\\rho \\neq 0)\"\n)\n\npval_ht = function(topics = ht_topics, seed = NULL) {\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    seed,\n    !!!slice_sample(topics, n=1),\n    alpha = sample(c(0.01, 0.05, 0.1), size = 1, prob = c(0.2, 0.6, 0.2)),\n    pval = round(rexp(1, rate = 14), 3),\n    ht_result = if (pval <= alpha) \"reject\" else \"do not reject\",\n    donot = if (pval <= alpha) \"\" else \" do not\"\n  )\n  \n  question_template = r\"(You want to test whether <<topic>>. In your analysis, you calculate a p-value of <<pval>>.)\"\n  subquestion_templates = list(\n    r\"(Give appropriate null and alternative hypotheses.)\",\n    r\"(Make a formal decision regarding the null hypothesis with significance level $\\alpha=<<alpha>>$.)\",\n    r\"(Interpret your decision in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Hypotheses: \n    - $H_0: <<null>>$\n    - $H_a: <<alt>>$)\",\n    r\"(Formal Decision: We see that $p = <<pval>> <<comp(pval, alpha)>> <<alpha>> = \\alpha$, so we <<ht_result>> the null hypothesis)\",\n    r\"(Interpretation: We<<donot>> have enough evidence to conclude that <<topic>>.)\"\n  )\n  \n  return(compile_problem(\n    setup,\n    question_template = question_template,\n    subquestion_templates = subquestion_templates,\n    subsolution_templates = subsolution_templates\n  ))\n}\n\nbootstrap_mean_hist_ci = function(\n    topics = means_topics, seed = NULL\n)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    seed,\n    details = topics %>% slice_sample(n=1),\n    topic = details$topic,\n    units = details$units,\n    mu = details$mu,\n    sigma = details$sigma,\n    sqrtn = sample(c(2, 5, 10, 20, 50), size=1),\n    se = round(sigma/sqrtn, 2),\n    xbar = round(rnorm(n=1, mean=mu, sd=se), 1),\n    bootstrap = rnorm(n=5000, mean=xbar, sd=se),\n    # Solution steps\n    lb = round(xbar - 2*se, 3),\n    ub = round(xbar + 2*se, 3)\n  )\n  \n  question_template = r\"(Suppose you are studying the average <<topic>>. You observe a sample mean of <<xbar>> <<units>>. Using your sample, you generate a bootstrap distribution and calculate its mean and standard deviation (shown in the figure).)\"\n  subquestion_templates = list(\n    r\"(Identify the parameter of interest both in words and in symbol(s).)\",\n    r\"(Using the bootstrap distribution, estimate the standard error for the sample mean.)\",\n    r\"(Using the 95% rule, calculate a 95% confidence interval for your parameter.)\",\n    r\"(Interpret your confidence interval in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(We are estimating $\\mu$, the average <<topic>>.)\",\n    r\"(The standard error is estimated using the standard deviation of the boostrap distribution, so $SE = \\text{bootstrap } SD = <<se>>$)\",\n    r\"(Using the 95% rule, the 95% confidence interval is $\\bar{x} \\pm 2(SE) = (<<lb>>, <<ub>>)$\n    - Lower bound: $<<xbar>> - 2(<<se>>) = <<lb>>$\n    - Upper bound: $<<xbar>> + 2(<<se>>) = <<ub>>$)\",\n    r\"(We are 95% confident that the average <<topic>> is between <<lb>> and <<ub>> <<units>>.)\"\n  )\n  \n  figure_templates = list(\n    function(setup) {\n      with(setup, {\n        hist(bootstrap, freq = FALSE, xlim=c(xbar-4*se, xbar+4*se), main=\"Bootstrap Distribution\", xlab=\"\", ylab=\"\", yaxt=\"n\")\n        legend(\"topright\", legend=c(paste0(\"Mean=\", xbar), paste0(\"SD=\", se)), bty=\"n\")\n      })\n    }\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)}),\n    figures = sapply(figure_templates, function(x) {compile_figure(x, setup)})\n  ))\n}\n\nrandomization_mean_ht = function(\n    topics = means_topics, seed = NULL\n)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    nrand = 100,\n    details = topics %>% slice_sample(n=1),\n    topic = details$topic,\n    units = details$units,\n    mu = details$mu,\n    sigma = details$sigma,\n    alpha = sample(c(0.01, 0.05, 0.1), size = 1, prob = c(0.2, 0.6, 0.2)),\n    ineq = sample(c(\"<\", \">\", NEQ), size = 1),\n    sqrtn = sample(c(2, 5, 10, 20, 50), size=1),\n    se = round(sigma/sqrtn, 2),\n    rand_dist = rnorm(n = nrand, mean = mu, sd = se),\n    dplot = dotplot(x = rand_dist, breaks=20, plot = FALSE),\n    xbar = sample(dplot$breaks, size = 1),\n    # Solution steps\n    mask_gt = dplot$stacks$x > xbar,\n    mask = if (ineq == \"<\" || (ineq == NEQ && xbar < mu)) !mask_gt else mask_gt,\n    extr = sum(mask),\n    pval = if (ineq == NEQ) round(2 * extr / nrand, 3) else round(extr / nrand, 3),\n    ht_result = ifelse(pval <= alpha, \"reject\", \"fail to reject\"),\n    donot = ifelse(pval <= alpha, \"\", \" do not\")\n  )\n  \n  question_template = r\"(You want to test whether the average <<topic>> is <<lgd(ineq)>> than <<mu>> <<units>> (gray line). Suppose you generate <<nrand>> randomization statistics, as shown in the figure.  Your sample statistic $\\bar{x} = <<xbar>>$ <<units>> (black line).)\"\n  subquestion_templates = list(\n    r\"(Write out the null and alternative hypotheses for this test.)\",\n    r\"(Using the randomization distribution, calculate the p-value of your sample statistic.)\",\n    r\"(Make a formal decision regarding the null hypothesis with $\\alpha=<<alpha>>$.)\",\n    r\"(Interpret your decision in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Hypotheses: \n    - $H_0: \\mu = <<mu>>$ \n    - $H_a: \\mu <<ineq>> <<mu>>$)\",\n    if (setup$ineq != NEQ)\n      r\"(There are <<extr>> randomization statistics more extreme than our sample statistic (colored red) out of <<nrand>>, so our p-value is <<extr>> / <<nrand>> = <<pval>>.)\"\n    else\n      r\"(There are <<extr>> randomization statistics more extreme than our sample statistic (colored red) out of <<nrand>>, and our alternative hypothesis is two-sided, so our p-value is 2 * <<extr>> / <<nrand>> = <<pval>>.)\",\n    r\"(We see that $p = <<pval>> <<comp(pval, alpha)>> <<alpha>> = \\alpha$, so we <<ht_result>> the null hypothesis.)\",\n    r\"(We<<donot>> have enough evidence to conclude that the average <<topic>> is <<lgd(ineq)>> than <<mu>> <<units>>.)\"\n  )\n  \n  figure_templates = list(\n    function(setup) {\n      with(setup, {\n        dotplot(rand_dist, breaks=20, xlab=\"\", pch=19)\n        abline(v=mu, col=\"gray\")\n        abline(v=xbar, col=\"black\")\n      })\n    }\n  )\n  \n  sol_figure_templates = list(\n    function(setup) {\n      with(setup, {\n        dotplot(rand_dist, breaks=20, xlab=\"\", pch=19)\n        points(dplot$stacks[mask, ], pch=19, col=\"red\")\n        abline(v=mu, col=\"gray\")\n        abline(v=xbar, col=\"black\")\n      })\n    }\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)}),\n    figures = sapply(figure_templates, function(x) {compile_figure(x, setup)}),\n    sol_figures = sapply(sol_figure_templates, function(x) {compile_figure(x, setup)})\n  ))\n}\n\n\n\n","type":"text"},{"name":"R/unit_c.R","content":"# source(\"compile_problem.R\")\n# source(\"question_helpers.R\")\n\nproportion_topics = tribble(\n  ~categ, ~quality, ~ps, ~p0s,\n  \"college students\", \"prefer to wake up early\", c(0.162), c(0.1,0.15,0.2,0.25),\n  \"college students\", \"prefer to stay up late\", c(0.194), c(0.1,0.15,0.2,0.25)\n)\n\nprop_ci = function(topics = proportion_topics, seed=NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    seed,\n    !!!slice_sample(topics, n=1),\n    p = sample(ps[[1]], size = 1),\n    n = round(rnbinom(n=1, size=5, prob=0.02)),\n    cl = sample(c(0.8, 0.9, 0.95, 0.98, 0.99), size=1, prob=c(0.1, 0.2, 0.4, 0.1, 0.2)),\n    succ = round(rbinom(n=1, size=n, prob = p)),\n    fail = round(n - succ),\n    phat = round(succ / n, 3),\n    # Solution Steps\n    met1 = if (n*phat >= 10) \"Met\" else \"Not met\",\n    met2 = if (n*(1-phat) >= 10) \"Met\" else \"Not met\",\n    se = round(sqrt(phat*(1-phat)/n), 3),\n    q = round((1 + cl) / 2, 3),\n    zstar = round(qnorm(q), 3),\n    lb = round(phat - zstar * se, 3),\n    ub = round(phat + zstar * se, 3),\n  )\n  \n  question_template = r\"(You are estimating the proportion of <<categ>> that <<quality>> and you decide to calculate a <<cl*100>>% confidence interval.\n  You collect a sample of <<n>> <<categ>> and find that <<phat*100>>% of them <<quality>>.)\"\n  subquestion_templates = list(\n    r\"(Identify the parameter you are estimating in both words and symbols.)\",\n    r\"(Calculate your sample statistic.)\",\n    r\"(Show whether the sample size conditions are met.)\",\n    r\"(Calculate the standard error.)\",\n    r\"(Calculate the appropriate multiplier including its symbol and, if necessary, degrees of freedom.)\",\n    r\"(Calculate the end points of the confidence interval.)\",\n    r\"(Interpret the confidence interval in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Parameter: The proportion of <<categ>> that <<quality>>. Symbol: $p$)\",\n    \n    r\"(Sample Statistic: $\\widehat{p} = <<phat>>$)\",\n    \n    r\"(Condition 1 $(n \\widehat{p} \\geq 10)$: <<met1>>, $\\enspace$ \n    Condition 2 $(n (1 - \\widehat{p}) \\geq 10)$: <<met2>>, $\\enspace$)\",\n    \n    r\"(Standard error: $SE = \\sqrt{\\widehat{p} (1-\\widehat{p}) / n}$ $= \\sqrt{<<phat>> (1-<<phat>>) / <<n>>} = <<se>>$.)\",\n    \n    r\"(Multiplier: We need the (1 + <<cl>>) / 2 = <<q>> quantile of the standard normal distribution, and $z^*$ = `qnorm(<<q>>)` = <<zstar>>.)\",\n    \n    r\"(Confidence Interval: $\\widehat{p} \\pm z^* \\times SE$ $= (<<lb>>, <<ub>>)$\n    \n    - Lower bound: $<<phat>> - <<zstar>> (<<se>>) = <<lb>>$\n    \n    - Upper bound: $<<phat>> + <<zstar>> (<<se>>) = <<ub>>$)\",\n    \n    r\"(Interpretation: We are <<cl*100>>\\% confident that the proportion of <<categ>> that <<quality>> is between <<lb>> and <<ub>>.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\n\nprop_ht = function(\n    topics = proportion_topics, seed = NULL\n)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    seed,\n    !!!slice_sample(topics, n=1),\n    p = sample(ps[[1]], size = 1),\n    p0 = sample(p0s[[1]], size = 1),\n    ineq = sample(c(\">\", \"<\", NEQ), size = 1),\n    alpha = sample(c(0.01, 0.05, 0.1), size = 1, prob = c(0.2, 0.6, 0.2)),\n    n = rnbinom(n=1, size=5, prob=0.02),\n    successes = rbinom(n=1, size=n, prob = p),\n    failures = n - successes,\n    phat = round(successes / n, 3),\n    # Solution steps\n    cond1 = ifelse(successes >= 10, \"Met\", \"Not met\"),\n    cond2 = ifelse(failures >= 10, \"Met\", \"Not met\"),\n    se = round(sqrt(p0*(1-p0)/n), 3),\n    z = round((phat - p0)/se, 3),\n    lower_tail_tf = lower_tail(ineq, z),\n    pval1t = round(pnorm(z, lower.tail = lower_tail_tf), 3),\n    pval = round(z_ineq_pval(z, ineq), 3),\n    ht_result = if (pval <= alpha) \"reject\" else \"do not reject\",\n    donot = if (pval <= alpha) \"\" else \" do not\"\n  )\n  \n  question_template = r\"(You want to test whether the proportion of <<categ>> that <<quality>> is <<lgd(ineq)>> than <<100*p0>>%. \n  You collect a sample of <<n>> <<categ>> and find that <<phat*100>>% of them <<quality>>.)\"\n  subquestion_templates = list(\n    r\"(Write out the null and alternative hypotheses for your test.)\",\n    r\"(Calculate the sample statistic.)\",\n    r\"(Show whether the sample size conditions are met.)\",\n    r\"(Calculate the standard error.)\",\n    r\"(Calculate the appropriate test statistic, including its symbol and, if necessary, degrees of freedom.)\",\n    r\"(Calculate the p-value.)\",\n    r\"(Make a formal decision regarding the null hypothesis with significance level $\\alpha=<<alpha>>$.)\",\n    r\"(Interpret your decision in the context of the problem.)\"\n  )\n  subsolution_templates = list(\n    r\"(Hypotheses: \n    - $H_0: p = <<p0>>$\n    - $H_a: p <<ineq>> <<p0>>$)\",\n    \n    r\"(Sample Statistic: $\\widehat{p} = <<phat>>$)\",\n    \n    r\"(Sample Size Condition 1 $(n p_0 = <<n>> (<<p0>>) = <<successes>> \\geq 10)$: <<cond1>>, $\\enspace$\n    Sample Size Condition 2 $(n (1-p_0) = <<n>> (1-<<p0>>) = <<failures>> \\geq 10)$: <<cond2>>)\",\n    \n    r\"(Standard Error: $SE = \\sqrt{<<p0>>(1-<<p0>>) / <<n>>} = <<se>>$.)\",\n    \n    r\"(Test Statistic: $z = (\\widehat{p} - p_0)/SE = (<<phat>> - <<p0>>) / <<se>> = <<z>>$.)\",\n    \n    if (setup$ineq == NEQ)\n      r\"(p-value: `pnorm(<<z>>, lower.tail=<<lower_tail_tf>>)` = <<pval1t>>, but our alternative is two-sided, so p-val = 2 * <<pval1t>> = <<pval>>)\" \n    else\n      r\"(p-value: `pnorm(<<z>>, lower.tail=<<lower_tail_tf>>)` = <<pval1t>>, so p-val = <<pval>>)\",\n    \n    r\"(Formal Decision: We see that $p = <<pval>> <<comp(pval, alpha)>> <<alpha>> = \\alpha$, so we <<ht_result>> the null hypothesis)\",\n    \n    r\"(Interpretation: We<<donot>> have enough evidence to conclude that the proportion of <<categ>> that <<quality>> is <<lgd(ineq)>> than <<round(p0*100,1)>>%.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\n\nprop_ht_noscaf = function(\n    topics = proportion_topics, seed = NULL\n)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    seed,\n    !!!slice_sample(topics, n=1),\n    p = sample(ps[[1]], size = 1),\n    p0 = sample(p0s[[1]], size = 1),\n    ineq = sample(c(\">\", \"<\", NEQ), size = 1),\n    alpha = sample(c(0.01, 0.05, 0.1), size = 1, prob = c(0.2, 0.6, 0.2)),\n    n = rnbinom(n=1, size=5, prob=0.02),\n    successes = rbinom(n=1, size=n, prob = p),\n    failures = n - successes,\n    phat = round(successes / n, 3),\n    # Solution steps\n    cond1 = ifelse(successes >= 10, \"Met\", \"Not met\"),\n    cond2 = ifelse(failures >= 10, \"Met\", \"Not met\"),\n    se = round(sqrt(p0*(1-p0)/n), 3),\n    z = round((phat - p0)/se, 3),\n    lower_tail_tf = lower_tail(ineq, z),\n    pval1t = round(pnorm(z, lower.tail = lower_tail_tf), 3),\n    pval = round(z_ineq_pval(z, ineq), 3),\n    ht_result = if (pval <= alpha) \"reject\" else \"do not reject\",\n    donot = if (pval <= alpha) \"\" else \" do not\"\n  )\n  \n  question_template = r\"(You want to test whether the proportion of <<categ>> that <<quality>> is <<lgd(ineq)>> than <<100*p0>>%. \n  You collect a sample of <<n>> <<categ>> and find that <<phat*100>>% of them <<quality>>.\n  Perform a hypothesis test with significance level $\\alpha=<<alpha>>$.)\"\n  solution_template = r\"(\n  - Hypotheses: $H_0: p = <<p0>>, \\quad H_a: p <<ineq>> <<p0>>$\n  \n  - Sample Statistic: $\\widehat{p} = <<phat>>$\n  \n  - Sample Size Condition 1 $(n p_0 = <<n>> (<<p0>>) = <<successes>> \\geq 10)$: <<cond1>>\n  \n  - Sample Size Condition 2 $(n (1-p_0) = <<n>> (1-<<p0>>) = <<failures>> \\geq 10)$: <<cond2>>\n  \n  - Standard Error: $SE = \\sqrt{<<p0>>(1-<<p0>>) / <<n>>} = <<se>>$\n  \n  - Test Statistic: $z = (\\widehat{p} - p_0)/SE = (<<phat>> - <<p0>>) / <<se>> = <<z>>$\n  \n  - p-value: `pnorm(<<z>>, lower.tail=<<lower_tail_tf>>)` = <<pval1t>>, so p-val = <<pval>>\n  \n  - Formal Decision: We see that $p = <<pval>> <<comp(pval, alpha)>> <<alpha>> = \\alpha$, so we <<ht_result>> the null hypothesis\n  \n  - Interpretation: We<<donot>> have enough evidence to conclude that the proportion of <<categ>> that <<quality>> is <<lgd(ineq)>> than <<round(p0*100,1)>>%.\n  )\"\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    solution = compile_text(solution_template, setup)\n  ))\n}\n\n\nmean_ci = function(topics = means_topics, seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    seed,\n    !!!slice_sample(topics, n=1),\n    # topic_row = topics %>% slice_sample(n = 1),\n    # topic = topic_row$topic,\n    # cases = topic_row$cases,\n    # units = topic_row$units,\n    # mu = topic_row$mu,\n    # sigma = topic_row$sigma,\n    n = round(rnbinom(n=1, size=5, prob=0.02)),\n    cl = sample(c(0.8, 0.9, 0.95, 0.98, 0.99), size=1, prob=c(0.1, 0.2, 0.4, 0.1, 0.2)),\n    s = round(sigma*sqrt(rchisq(n=1, df=n-1) / (n-1)), 2), # cite: https://web.eecs.umich.edu/~fessler/papers/files/tr/stderr.pdf\n    se = round(s / sqrt(n), 3),\n    xbar = round(rnorm(n=1, mean=mu, sd=se), 2),\n    # Solution Steps\n    met = if (n >= 30) \"Met\" else \"Not met\",\n    se = round(s / sqrt(n), 3),\n    q = round((1 + cl) / 2, 3),\n    df = round(n - 1),\n    tstar = round(qt(q, df=df), 3),\n    lb = round(xbar - tstar * se, 3),\n    ub = round(xbar + tstar * se, 3),\n  )\n  \n  question_template = r\"(You are estimating the average <<topic>> and you decide to calculate a <<cl*100>>% confidence interval.\n  You collect a sample of <<n>> <<cases>> and calculate an average of <<xbar>> <<units>> with standard deviation <<s>> <<units>>.)\"\n  subquestion_templates = list(\n    r\"(Identify the parameter you are estimating in both words and symbols.)\",\n    r\"(Calculate your sample statistic.)\",\n    r\"(Show whether the sample size conditions are met.)\",\n    r\"(Calculate the standard error.)\",\n    r\"(Calculate the appropriate multiplier including its symbol and, if necessary, degrees of freedom.)\",\n    r\"(Calculate the end points of the confidence interval.)\",\n    r\"(Interpret the confidence interval in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Parameter: The average <<topic>>. Symbol: $\\mu$)\",\n    \n    r\"(Sample Statistic: $\\bar{x} = <<xbar>>$)\",\n    \n    r\"(Condition $(n \\geq 30)$: <<met>>)\",\n    \n    r\"(Standard error: $SE = s / \\sqrt{n}$ $= <<s>> / \\sqrt{<<n>>} = <<se>>$.)\",\n    \n    r\"(Multiplier: We need the (1 + <<cl>>) / 2 = <<q>> quantile of the $t$ distribution with $df = n - 1 = <<df>>$ degrees of freedom, and $t^*$ = `qt(<<q>>, df=<<df>>)` = <<tstar>>.)\",\n    \n    r\"(Confidence Interval: $\\bar{x} \\pm t^* \\times SE$ $= (<<lb>>, <<ub>>)$\n    - Lower bound: $<<xbar>> - <<tstar>> (<<se>>) = <<lb>>$\n    - Upper bound: $<<xbar>> + <<tstar>> (<<se>>) = <<ub>>$)\",\n    \n    r\"(Interpretation: We are <<cl*100>>% confident that the average <<topic>> is between <<lb>> and <<ub>> <<units>>.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\n\nmean_ht = function(topics = means_topics, pnull=0.5, seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    pnull, seed,\n    !!!slice_sample(topics, n=1),\n    mu0 = sample(nulls[[1]], 1),\n    ineq = sample(c(\">\", \"<\", NEQ), size = 1),\n    alpha = sample(c(0.01, 0.05, 0.1), size = 1, prob = c(0.2, 0.6, 0.2)),\n    n = round(rnbinom(n=1, size=5, prob=0.02)),\n    s = round(sigma*sqrt(rchisq(n=1, df=n-1) / (n-1)), 2), # cite: https://web.eecs.umich.edu/~fessler/papers/files/tr/stderr.pdf\n    se = round(s / sqrt(n), 3),\n    xbar = round(rnorm(n=1, mean=mu, sd=se), 2),\n    # Solution Steps\n    met = if (n >= 30) \"Met\" else \"Not met\",\n    tstat = round((xbar - mu0) / se, 3),\n    df = round(n - 1),\n    lower_tail_tf = lower_tail(ineq, tstat),\n    pval1t = round(pt(tstat, df=df, lower.tail = lower_tail_tf), 3),\n    pval = round(t_ineq_pval(tstat, df, ineq), 3),\n    ht_result = if (pval <= alpha) \"reject\" else \"do not reject\",\n    donot = if (pval <= alpha) \"\" else \" do not\"\n  )\n  \n  question_template = r\"(You want to test whether the average <<topic>> is <<lgd(ineq)>> than <<mu0>> <<units>>.\n  You collect a sample of <<n>> <<cases>> and calculate an average of <<xbar>> <<units>> with standard deviation <<s>> <<units>>.)\"\n  subquestion_templates = list(\n    r\"(Write out the null and alternative hypotheses for your test.)\",\n    r\"(Calculate the sample statistic.)\",\n    r\"(Show whether the sample size conditions are met.)\",\n    r\"(Calculate the standard error.)\",\n    r\"(Calculate the appropriate test statistic, including its symbol and, if necessary, degrees of freedom.)\",\n    r\"(Calculate the p-value.)\",\n    r\"(Make a formal decision regarding the null hypothesis with significance level $\\alpha=<<alpha>>$.)\",\n    r\"(Interpret your decision in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Hypotheses: \n    - $H_0: \\mu = <<mu0>>$\n    - $H_a: \\mu <<ineq>> <<mu0>>$)\",\n    \n    r\"(Sample statistic: $\\bar{x} = <<xbar>>.$)\",\n    \n    if (setup$n >= 30)\n      r\"(Condition $(n \\geq 30)$: <<met>>)\" else\n      r\"(Condition $(n \\geq 30)$: <<met>>, $\\enspace$ The condition is NOT met, but if the data looks normal (not shown), then the conditions would be met.)\",\n    \n    r\"(Standard error: $SE = s / \\sqrt{n} = <<s>> / \\sqrt{<<n>>} = <<se>>$.)\",\n    \n    r\"(Test statistic: $t = (\\bar{x} - \\mu_{0}) / SE = (<<xbar>> - <<mu0>>) / <<se>> = <<tstat>>$. \n    Degrees of freedom: $df = n - 1 = <<df>>$.)\",\n    \n    if (setup$ineq == NEQ)\n      r\"(p-value: `pt(<<tstat>>, df=<<df>>, lower.tail=<<lower_tail_tf>>)` = <<pval1t>>, but our alternative is two-sided, so p-val = 2 * <<pval1t>> = <<pval>>)\" else\n      r\"(p-value: `pt(<<tstat>>, df=<<df>>, lower.tail=<<lower_tail_tf>>)` = <<pval1t>>, so p-val = <<pval>>)\",\n    \n    r\"(Formal Decision: We see that $p = <<pval>> <<comp(pval, alpha)>> <<alpha>> = \\alpha$, so we <<ht_result>> the null hypothesis)\",\n    \n    r\"(Interpretation: We<<donot>> have enough evidence to conclude that the average <<topic>> is <<lgd(ineq)>> than <<mu0>> <<units>>.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\n\ndiffprop_ci_topics = tribble(\n  ~cat1, ~symb1, ~p1, ~cat2, ~symb2, ~p2, ~quality,\n  \"men\", \"m\", 0.72, \"women\", \"w\", 0.7, \"watch more than 30 minutes of TV or video per day\"\n)\n\ndiffprop_ci = function(topics = diffprop_ci_topics, seed=NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    seed,\n    !!!slice_sample(topics, n=1),\n    # topic_row = topics %>% slice_sample(n = 1),\n    # cat1 = topic_row$cat1,\n    # symb1 = topic_row$symb1,\n    # p1 = topic_row$p1,\n    # cat2 = topic_row$cat2,\n    # symb2 = topic_row$symb2,\n    # p2 = topic_row$p2,\n    # quality = topic_row$quality,\n    n = round(rnbinom(n=1, size=5, prob=0.02)),\n    n1 = round(n / 4 + rbinom(n=1, size=n %/% 2, prob=0.5)),\n    n2 = round(n - n1),\n    cl = sample(c(0.8, 0.9, 0.95, 0.98, 0.99), size=1, prob=c(0.1, 0.2, 0.4, 0.1, 0.2)),\n    succ1 = round(rbinom(n=1, size=n1, prob = p1)),\n    fail1 = round(n1 - succ1),\n    phat1 = round(succ1 / n1, 3),\n    succ2 = round(rbinom(n=1, size=n2, prob = p2)),\n    fail2 = round(n2 - succ2),\n    phat2 = round(succ2 / n2, 3),\n    # Solution Steps\n    diffp = round(phat1 - phat2, 3),\n    met1 = if (n1*phat1 >= 10) \"Met\" else \"Not met\",\n    met2 = if (n1*(1-phat1) >= 10) \"Met\" else \"Not met\",\n    met3 = if (n2*phat2 >= 10) \"Met\" else \"Not met\",\n    met4 = if (n2*(1-phat2) >= 10) \"Met\" else \"Not met\",\n    se=round(sqrt(phat1*(1-phat1)/n1 + phat2*(1-phat2)/n2), 3),\n    q = round((1 + cl) / 2, 3),\n    zstar = round(qnorm(q), 3),\n    lb = round(diffp - zstar * se, 3),\n    ub = round(diffp + zstar * se, 3),\n  )\n  \n  question_template = r\"(You are estimating the difference between the proportions of <<cat1>> and <<cat2>> that <<quality>> and you decide to calculate a <<cl*100>>% confidence interval.\n  You collect a sample of <<n1>> <<cat1>> and <<n2>> <<cat2>> and find that <<phat1*100>>% of <<cat1>> and <<phat2*100>>% of <<cat2>> <<quality>>.)\"\n  subquestion_templates = list(\n    r\"(Identify the parameter you are estimating in both words and symbols.)\",\n    r\"(Calculate your sample statistic.)\",\n    r\"(Show whether the sample size conditions are met.)\",\n    r\"(Calculate the standard error.)\",\n    r\"(Calculate the appropriate multiplier including its symbol and, if necessary, degrees of freedom.)\",\n    r\"(Calculate the end points of the confidence interval.)\",\n    r\"(Interpret the confidence interval in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Parameter: The difference between the proportions of <<cat1>> and <<cat2>> that <<quality>>. Symbol: $p_{<<symb1>>} - p_{<<symb2>>}$)\",\n    \n    r\"(Sample Statistic: $\\widehat{p}_{<<symb1>>} - \\widehat{p}_{<<symb2>>}$ = $<<phat1>> - <<phat2>>$ = $<<diffp>>$)\",\n    \n    r\"(Condition 1 $(n_{<<symb1>>} \\widehat{p}_{<<symb1>>} \\geq 10)$: <<met1>>, $\\enspace$ \n    Condition 2 $(n_{<<symb1>>} (1 - \\widehat{p}_{<<symb1>>}) \\geq 10)$: <<met2>>, $\\enspace$\n    Condition 3 $(n_{<<symb2>>} \\widehat{p}_{<<symb2>>} \\geq 10)$: <<met3>>, $\\enspace$ \n    Condition 4 $(n_{<<symb2>>} (1 - \\widehat{p}_{<<symb2>>}) \\geq 10)$: <<met4>>, $\\enspace$)\",\n    \n    r\"(Standard error: $SE = \\sqrt{\\widehat{p}_{<<symb1>>} (1-\\widehat{p}_{<<symb1>>}) / n_{<<symb1>>} + \\widehat{p}_{<<symb2>>} (1-\\widehat{p}_{<<symb2>>}) / n_{<<symb2>>}}$ $= \\sqrt{<<phat1>> (1-<<phat1>>) / <<n1>> + <<phat2>> (1-<<phat2>>) / <<n2>>} = <<se>>$.)\",\n    \n    r\"(Multiplier: We need the (1 + <<cl>>) / 2 = <<q>> quantile of the standard normal distribution, and $z^*$ = `qnorm(<<q>>)` = <<zstar>>.)\",\n    \n    r\"(Confidence Interval: $\\widehat{p}_{<<symb1>>} - \\widehat{p}_{<<symb2>>} \\pm z^* \\times SE$ $= (<<lb>>, <<ub>>)$\n    - Lower bound: $(<<phat1>> - <<phat2>>) - <<zstar>> (<<se>>) = <<lb>>$\n    - Upper bound: $(<<phat1>> - <<phat2>>) + <<zstar>> (<<se>>) = <<ub>>$)\",\n    \n    r\"(Interpretation: We are <<cl*100>>% confident that the difference between the proportions of <<cat1>> and <<cat2>> that <<quality>> is between <<lb>> and <<ub>>.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\ndiffprop_ht_topics = tribble(\n  ~cat1, ~symb1, ~cat2, ~symb2, ~quality, ~p,\n  \"men\", \"m\", \"women\", \"w\", \"watch more than 30 minutes of TV or video per day\", 0.7\n)\n\ndiffprop_ht = function(topics = diffprop_ht_topics, pnull=0.5, seed = NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    pnull, seed,\n    !!!slice_sample(topics, n=1),\n    # topic_row = topics %>% slice_sample(n = 1),\n    # cat1 = topic_row$cat1,\n    # symb1 = topic_row$symb1,\n    # cat2 = topic_row$cat2,\n    # symb2 = topic_row$symb2,\n    # quality = topic_row$quality,\n    # p = topic_row$p,\n    ineq = sample(c(\">\", \"<\", NEQ), size = 1),\n    alpha = sample(c(0.01, 0.05, 0.1), size = 1, prob = c(0.2, 0.6, 0.2)),\n    n = round(rnbinom(n=1, size=5, prob=0.02)),\n    n1 = round(n / 4 + rbinom(n=1, size=n %/% 2, prob=0.5)),\n    n2 = round(n - n1),\n    fake_se = sqrt(p*(1-p)*(1/n1 + 1/n2)),\n    true_diffp = \n      sample(0:1, size = 1, prob = c(pnull, 1-pnull)) * # pnull chance for the null to be true / diff = 0\n      rexp(n = 1, rate = 1) * 3 * fake_se, # if null false, true diff prop will be exponentially distributed with mean 3*fake_SE\n    max_p = round(p + true_diffp / 2, 3),\n    min_p = round(p - true_diffp / 2, 3),\n    p1 = if (ineq == \"<\") min_p else max_p,\n    p2 = if (ineq == \"<\") max_p else min_p,\n    succ1 = round(rbinom(n=1, size=n1, prob = p1)),\n    fail1 = round(n1 - succ1),\n    phat1 = round(succ1 / n1, 3),\n    succ2 = round(rbinom(n=1, size=n2, prob = p2)),\n    fail2 = round(n2 - succ2),\n    phat2 = round(succ2 / n2, 3),\n    # Solution Steps\n    diffp = round(phat1 - phat2, 3),\n    poolp = round((succ1 + succ2) / (n1 + n2), 3),\n    met1 = if (n1*poolp >= 10) \"Met\" else \"Not met\",\n    met2 = if (n1*(1-poolp) >= 10) \"Met\" else \"Not met\",\n    met3 = if (n2*poolp >= 10) \"Met\" else \"Not met\",\n    met4 = if (n2*(1-poolp) >= 10) \"Met\" else \"Not met\",\n    se = round(sqrt(poolp*(1-poolp)*(1/n1 + 1/n2)), 3),\n    zstat = round(diffp / se, 3),\n    lower_tail_tf = lower_tail(ineq, zstat),\n    pval1t = round(pnorm(zstat, lower.tail = lower_tail_tf), 3),\n    pval = round(z_ineq_pval(zstat, ineq), 3),\n    ht_result = if (pval <= alpha) \"reject\" else \"do not reject\",\n    donot = if (pval <= alpha) \"\" else \" do not\"\n  )\n  \n  question_template = r\"(You want to test whether the proportion of <<cat1>> that <<quality>> is <<lgd(ineq)>> than the same proportion for <<cat2>>. \n  You collect a sample of <<n1>> <<cat1>> and <<n2>> <<cat2>> and find that <<phat1*100>>% of <<cat1>> and <<phat2*100>>% of <<cat2>> <<quality>>.)\"\n  subquestion_templates = list(\n    r\"(Write out the null and alternative hypotheses for your test.)\",\n    r\"(Calculate the sample statistic.)\",\n    r\"(Show whether the sample size conditions are met.)\",\n    r\"(Calculate the standard error.)\",\n    r\"(Calculate the appropriate test statistic, including its symbol and, if necessary, degrees of freedom.)\",\n    r\"(Calculate the p-value.)\",\n    r\"(Make a formal decision regarding the null hypothesis with significance level $\\alpha=<<alpha>>$.)\",\n    r\"(Interpret your decision in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Hypotheses: \n    - $H_0: p_{<<symb1>>} = p_{<<symb2>>}$\n    - $H_a: p_{<<symb1>>} <<ineq>> p_{<<symb2>>}$)\",\n    \n    r\"(Sample statistic: $\\widehat{p}_{<<symb1>>} - \\widehat{p}_{<<symb2>>} = <<phat1>> - <<phat2>> = <<diffp>>.$)\",\n    \n    r\"(Pooled proportion $p_{p} = (n_{<<symb1>>} \\widehat{p}_{<<symb1>>} + n_{<<symb2>>} \\widehat{p}_{<<symb2>>}) / (n_{<<symb1>>} + n_{<<symb2>>}) = ((<<n1>>)(<<phat1>>) + (<<n2>>)(<<phat2>>)) / (<<n1>> + <<n2>>)= <<poolp>>$. \n    Condition 1 $(n_{<<symb1>>} \\widehat{p}_{p} \\geq 10)$: <<met1>>, $\\enspace$ \n    Condition 2 $(n_{<<symb1>>} (1 - \\widehat{p}_{p}) \\geq 10)$: <<met2>>, $\\enspace$\n    Condition 3 $(n_{<<symb2>>} \\widehat{p}_{p} \\geq 10)$: <<met3>>, $\\enspace$ \n    Condition 4 $(n_{<<symb2>>} (1 - \\widehat{p}_{p}) \\geq 10)$: <<met4>>, $\\enspace$)\",\n    \n    r\"(Standard error: $SE$ = $\\sqrt{\\widehat{p}_{p} (1-\\widehat{p}_{p}) / n_{<<symb1>>} + \\widehat{p}_{p} (1-\\widehat{p}_{p}) / n_{<<symb2>>}}$ = $\\sqrt{<<poolp>> (1-<<poolp>>) / <<n1>> + <<poolp>> (1-<<poolp>>) / <<n2>>}$ = $<<se>>$.)\",\n    \n    r\"(Test statistic: $z = (\\widehat{p}_{<<symb1>>} - \\widehat{p}_{<<symb2>>}) / SE = (<<phat1>> - <<phat2>>) / <<se>> = <<zstat>>$.)\",\n    \n    if (setup$ineq == NEQ)\n      r\"(p-value: `pnorm(<<zstat>>, lower.tail=<<lower_tail_tf>>)` = <<pval1t>>, but our alternative is two-sided, so p-val = 2 * <<pval1t>> = <<pval>>)\" else\n      r\"(p-value: `pnorm(<<zstat>>, lower.tail=<<lower_tail_tf>>)` = <<pval1t>>, so p-val = <<pval>>)\",\n    \n    r\"(Formal Decision: We see that $p = <<pval>> <<comp(pval, alpha)>> <<alpha>> = \\alpha$, so we <<ht_result>> the null hypothesis)\",\n    \n    r\"(Interpretation: We<<donot>> have enough evidence to conclude that the proportion of <<cat1>> that <<quality>> is <<lgd(ineq)>> than the same proportion for <<cat2>>.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\ndiffmean_ci_topics = tribble(\n  ~topic, ~cat1, ~symb1, ~mu1, ~cat2, ~symb2, ~mu2, ~sigma, ~units,\n  \"difference between the average income for college graduates and non-college graduates\", \"college graduates\", \"c\", 59600, \"non-college graduates\", \"n\", 36600, 20000, \"dollars per year\"\n)\n\ndiffmean_ci = function(topics = diffmean_ci_topics, seed=NULL)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    seed,\n    !!!slice_sample(topics, n=1),\n    cl = sample(c(0.8, 0.9, 0.95, 0.98, 0.99), size=1, prob=c(0.1, 0.2, 0.4, 0.1, 0.2)),\n    n = round(rnbinom(n=1, size=5, prob=0.02)),\n    n1 = round(n / 4 + rbinom(n=1, size=n %/% 2, prob=0.5)),\n    n2 = round(n - n1),\n    s1 = round(sigma*sqrt(rchisq(n=1, df=n1-1) / (n1-1)), 2), # cite: https://web.eecs.umich.edu/~fessler/papers/files/tr/stderr.pdf\n    s2 = round(sigma*sqrt(rchisq(n=1, df=n2-1) / (n2-1)), 2),\n    true_se1 = round(s1 / sqrt(n1), 3),\n    true_se2 = round(s2 / sqrt(n2), 3),\n    xbar1 = round(rnorm(n=1, mean=mu1, sd=true_se1), 3),\n    xbar2 = round(rnorm(n=1, mean=mu2, sd=true_se2), 3),\n    # Solution Steps\n    diffx = round(xbar1 - xbar2, 3),\n    met1 = if (n1 >= 30) \"Met\" else \"Not met\",\n    met2 = if (n2 >= 30) \"Met\" else \"Not met\",\n    se = round(sqrt(s1^2 / n1 + s2^2 / n2), 3),\n    q = round((1 + cl) / 2, 3),\n    df = round(min(n1, n2) - 1),\n    tstar = round(qt(q, df=df), 3),\n    lb = round(diffx - tstar * se, 3),\n    ub = round(diffx + tstar * se, 3),\n  )\n  \n  question_template = r\"(You are estimating the <<topic>> and you decide to calculate a <<cl*100>>% confidence interval.\n  For <<cat1>>, you take a sample of size <<n1>> and calculate an average of <<xbar1>> <<units>> and a standard deviation of <<s1>> <<units>>.\n  For <<cat2>>, your sample size is <<n2>>, sample mean is <<xbar2>> <<units>>, and sample standard deviation is <<s2>> <<units>>.)\"\n  subquestion_templates = list(\n    r\"(Identify the parameter you are estimating in both words and symbols.)\",\n    r\"(Calculate your sample statistic.)\",\n    r\"(Show whether the sample size conditions are met.)\",\n    r\"(Calculate the standard error.)\",\n    r\"(Calculate the appropriate multiplier including its symbol and, if necessary, degrees of freedom.)\",\n    r\"(Calculate the end points of the confidence interval.)\",\n    r\"(Interpret the confidence interval in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Parameter: The <<topic>>. Symbol: $\\mu_{<<symb1>>} - \\mu_{<<symb2>>}$)\",\n    \n    r\"(Sample Statistic: $\\bar{x}_{<<symb1>>} - \\bar{x}_{<<symb1>>} = <<xbar1>> - <<xbar2>> = <<diffx>>$)\",\n    \n    if (setup$n1 >= 30 || setup$n2 >= 30)\n      r\"(Condition 1 $(n_{<<symb1>>} = <<n1>> \\geq 30)$: <<met1>>, $\\enspace$ Condition 2 $(n_{<<symb2>>} = <<n2>> \\geq 30)$: <<met2>>, $\\enspace$ Both conditions are met.)\" \n    else\n      r\"(Condition 1 $(n_{<<symb1>>} = <<n1>> \\geq 30)$: <<met1>>, $\\enspace$ Condition 2 $(n_{<<symb2>>} = <<n2>> \\geq 30)$: <<met2>>, $\\enspace$ Both conditions are NOT met, but if the data from both groups looks normal (not shown), then the conditions would be met.)\",\n    \n    r\"(Standard error: $SE = \\sqrt{s^2_{<<symb1>>} / n_{<<symb1>>} + s^2_{<<symb2>>} / n_{<<symb2>>}} = \\sqrt{(<<s1>>)^2 / <<n1>> + (<<s2>>)^2 / <<n2>>} = <<se>>$.)\",\n    \n    r\"(Multiplier: We need the (1 + <<cl>>) / 2 = <<q>> quantile of the $t$ distribution with $df = \\min(n_{<<symb1>>}, n_{<<symb2>>}) - 1 = <<df>>$ degrees of freedom, and $t^*$ = `qt(<<q>>, df=<<df>>)` = <<tstar>>.)\",\n    \n    r\"(Confidence Interval: $\\bar{x} \\pm t^* \\times SE$ $= (<<lb>>, <<ub>>)$\n    - Lower bound: $(<<xbar1>> - <<xbar2>>) - <<tstar>> (<<se>>) = <<lb>>$\n    - Upper bound: $(<<xbar1>> - <<xbar2>>) + <<tstar>> (<<se>>) = <<ub>>$)\",\n    \n    r\"(Interpretation: We are <<cl*100>>% confident that the average <<topic>> is between <<lb>> and <<ub>> <<units>>.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\ndiffmean_ht_topics = tribble(\n  ~topic, ~cat1, ~symb1, ~cat2, ~symb2, ~mu, ~sigma, ~units,\n  \"the average length of one gribble subspecies is <<lgd(ineq)>> than another\", \"subspecies 1\", \"1\", \"subspecies 2\", \"2\", 5.3, 2, \"mm\"\n)\n\ndiffmean_ht = function(topics = diffmean_ht_topics, pnull=0.5, seed = NULL) {\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    pnull, seed,\n    topic_row = topics %>% slice_sample(n = 1),\n    topic_raw = topic_row$topic,\n    cat1 = topic_row$cat1,\n    symb1 = topic_row$symb1,\n    cat2 = topic_row$cat2,\n    symb2 = topic_row$symb2,\n    mu = topic_row$mu,\n    sigma = topic_row$sigma,\n    units = topic_row$units,\n    ineq = sample(c(\">\", \"<\", NEQ), size = 1),\n    topic = compile_text(topic_raw),\n    alpha = sample(c(0.01, 0.05, 0.1), size = 1, prob = c(0.2, 0.6, 0.2)),\n    n = round(rnbinom(n=1, size=5, prob=0.02)),\n    n1 = round(n / 4 + rbinom(n=1, size=n %/% 2, prob=0.5)),\n    n2 = round(n - n1),\n    s1 = round(sigma*sqrt(rchisq(n=1, df=n1-1) / (n1-1)), 2), # cite: https://web.eecs.umich.edu/~fessler/papers/files/tr/stderr.pdf\n    s2 = round(sigma*sqrt(rchisq(n=1, df=n2-1) / (n2-1)), 2),\n    true_se1 = round(s1 / sqrt(n1), 3),\n    true_se2 = round(s2 / sqrt(n2), 3),\n    se = round(sqrt(s1^2 / n1 + s2^2 / n2), 3),\n    diffmu = \n      sample(0:1, size = 1, prob = c(pnull, 1-pnull)) * # pnull chance for the null to be true / diff = 0\n      rexp(n = 1, rate = 1) * 3 * se, # if null false, true diff mean will be exponentially distributed with mean 3*SE\n    max_mu = round(mu + diffmu / 2, 3),\n    min_mu = round(mu - diffmu / 2, 3),\n    mu1 = if (ineq == \"<\") min_mu else max_mu,\n    mu2 = if (ineq == \"<\") max_mu else min_mu,\n    xbar1 = round(rnorm(n=1, mean=mu1, sd=true_se1), 3),\n    xbar2 = round(rnorm(n=1, mean=mu2, sd=true_se2), 3),\n    # Solution Steps\n    diffx = round(xbar1 - xbar2, 3),\n    met1 = if (n1 >= 30) \"Met\" else \"Not met\",\n    met2 = if (n2 >= 30) \"Met\" else \"Not met\",\n    tstat = round((xbar1 - xbar2) / se, 3),\n    df = round(min(n1, n2) - 1),\n    lower_tail_tf = lower_tail(ineq, tstat),\n    pval1t = round(pt(tstat, df=df, lower.tail = lower_tail_tf), 3),\n    pval = round(t_ineq_pval(tstat, df, ineq), 3),\n    ht_result = if (pval <= alpha) \"reject\" else \"do not reject\",\n    donot = if (pval <= alpha) \"\" else \" do not\"\n  )\n\n  question_template = r\"(You want to test whether <<topic>>. \n  For <<cat1>>, you take a sample of size <<n1>> and calculate an average of <<xbar1>> <<units>> and a standard deviation of <<s1>> <<units>>.\n  For <<cat2>>, your sample size is <<n2>>, sample mean is <<xbar2>> <<units>>, and sample standard deviation is <<s2>> <<units>>.)\"\n  subquestion_templates = list(\n    r\"(Write out the null and alternative hypotheses for your test.)\",\n    r\"(Calculate the sample statistic.)\",\n    r\"(Show whether the sample size conditions are met.)\",\n    r\"(Calculate the standard error.)\",\n    r\"(Calculate the appropriate test statistic, including its symbol and, if necessary, degrees of freedom.)\",\n    r\"(Calculate the p-value.)\",\n    r\"(Make a formal decision regarding the null hypothesis with significance level $\\alpha=<<alpha>>$.)\",\n    r\"(Interpret your decision in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Hypotheses: \n    - $H_0: \\mu_{<<symb1>>} = \\mu_{<<symb2>>}$\n    - $H_a: \\mu_{<<symb1>>} <<ineq>> \\mu_{<<symb2>>}$)\",\n    \n    r\"(Sample statistic: $\\bar{x}_{<<symb1>>} - \\bar{x}_{<<symb2>>} = <<xbar1>> - <<xbar2>> = <<diffx>>.$)\",\n    \n    if (setup$n1 >= 30 || setup$n2 >= 30)\n      r\"(Condition 1 $(n_{<<symb1>>} \\geq 30)$: <<met1>>, $\\enspace$ Condition 2 $(n_{<<symb2>>} \\geq 30)$: <<met2>>, $\\enspace$ Both conditions are met.)\" else\n      r\"(Condition 1 $(n_{<<symb1>>} \\geq 30)$: <<met1>>, $\\enspace$ Condition 2 $(n_{<<symb2>>} \\geq 30)$: <<met2>>, $\\enspace$ Both conditions are NOT met, but if the data from both groups looks normal (not shown), then the conditions would be met.)\",\n    \n    r\"(Standard error: $SE = \\sqrt{s^2_{<<symb1>>} / n_{<<symb1>>} + s^2_{<<symb2>>} / n_{<<symb2>>}} = \\sqrt{(<<s1>>)^2 / <<n1>> + (<<s2>>)^2 / <<n2>>} = <<se>>$.)\",\n    \n    r\"(Test statistic: $t = (\\bar{x}_{<<symb1>>} - \\bar{x}_{<<symb2>>}) / SE = (<<xbar1>> - <<xbar2>>) / <<se>> = <<tstat>>$. \n    Degrees of freedom: $df = \\min(n_{<<symb1>>}, n_{<<symb2>>}) - 1 = <<df>>.$)\",\n    \n    if (setup$ineq == NEQ)\n      r\"(p-value: `pt(<<tstat>>, df=<<df>>, lower.tail=<<lower_tail_tf>>)` = <<pval1t>>, but our alternative is two-sided, so p-val = 2 * <<pval1t>> = <<pval>>)\" else\n      r\"(p-value: `pt(<<tstat>>, df=<<df>>, lower.tail=<<lower_tail_tf>>)` = <<pval1t>>, so p-val = <<pval>>)\",\n    \n    r\"(Formal Decision: We see that $p = <<pval>> <<comp(pval, alpha)>> <<alpha>> = \\alpha$, so we <<ht_result>> the null hypothesis)\",\n    \n    r\"(Interpretation: We<<donot>> have enough evidence to conclude that <<topic>>.)\"\n  )\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)})\n  ))\n}\n\n\n","type":"text"},{"name":"R/unit_d.R","content":"# source(\"compile_problem.R\")\n# source(\"question_helpers.R\")\n\nchi1d_equal_topics = tribble(\n  ~topic, ~dataname, ~options,\n  \"options A, B, C, and D have an unequal chance to be correct on multiple choice exams\", \"questions\", c(\"A\", \"B\", \"C\", \"D\"),\n  \"options A, B, C, D, and E have an unequal chance to be correct on multiple choice exams\", \"questions\", c(\"A\", \"B\", \"C\", \"D\", \"E\"),\n  \"the sides of your six-sided die (1, 2, 3, 4, 5, 6) have an unequal chance to be rolled\", \"rolls\", c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"),\n  \"the sides of your four-sided die (1, 2, 3, 4) have an unequal chance to be rolled\", \"rolls\", c(\"1\", \"2\", \"3\", \"4\")\n)\n\nchi1d_equal = function(\n    topics = chi1d_equal_topics,\n    pnull = 0.5,\n    mean_n = 250,\n    concentration = 10,\n    seed=NULL\n)\n{\n  if (!is.null(seed)) {\n    local_seed(seed)\n  }\n  setup = lst(\n    topic_row = topics %>% slice_sample(n = 1),\n    topic = topic_row$topic,\n    dataname = topic_row$dataname,\n    opts = topic_row$options[[1]],\n    k = length(opts),\n    alpha = sample(c(0.01, 0.05, 0.1), size = 1, prob = c(0.2, 0.6, 0.2)),\n    n = rnbinom(n=1, size=k, prob=k/(mean_n + k)),\n    null_true = sample(c(TRUE, FALSE), size=1, prob = c(pnull, 1-pnull)),\n    pdist = if (null_true) {rep(1/k, k)} else {rdist(k, concentration)},\n    obs = as.integer(rmultinom(n=1, size=n, prob = pdist)),\n    obs_tab = rbind(c(obs, n)) %>% set_colnames(c(opts, \"Total\")) %>% set_rownames(c(\"Count\")),\n    # Solution steps\n    # chisq_obj = chisq.test(x = obs, correct = FALSE),\n    p_chain = paste0(compile_text(r\"(p_{\\text{<<opts>>}})\"), collapse = \" = \"),\n    expect = round(n / k, 3),\n    met = if (expect >= 5) {\"Met\"} else {\"Not met\"},\n    contribs = round((obs - expect)^2 / expect, 3),\n    chisq = round(sum(contribs), 3),\n    df = round(k-1),\n    pval = round(pchisq(chisq, df = df, lower.tail = FALSE), 3),\n    ht_result = if (pval <= alpha) \"reject\" else \"do not reject\",\n    donot = if (pval <= alpha) \"\" else \" do not\"\n  )\n  \n  question_template = r\"(Suppose you want to test if <<topic>>. You collect data from <<n>> <<dataname>>, and you summarize it in the table shown.)\"\n  subquestion_templates = list(\n    r\"(What are the null and alternative hypotheses?)\",\n    r\"(What are the expected counts for each category?)\",\n    r\"(Show whether the conditions are met for performing a chi-square goodness-of-fit test. If they are not, continue anyway.)\",\n    r\"(What is the value of the chi-square test statistic?)\",\n    r\"(What is the value of the degrees of freedom for the chi-square test?)\",\n    r\"(What is the p-value?)\",\n    r\"(Make a formal decision regarding the null hypothesis with $\\alpha=<<alpha>>$.)\",\n    r\"(Interpret your decision in the context of the problem.)\"\n  )\n  \n  subsolution_templates = list(\n    r\"(Hypotheses: \n    - $H_0: <<p_chain>> = 1 / <<k>>$\n    - $H_a: \\text{At least one } p_i \\neq 1 / <<k>>$)\",\n    \n    r\"(Expected counts: For every category the expected count is $<<n>> (1 / <<k>>) = <<expect>>$)\",\n    r\"(Conditions: All expected counts (<<expect>>) at least 5: <<met>>)\",\n    r\"(Test Statistic:\n    - The contribution from category $i$ is $(O_{i} - E_{i})^2 / E_{i}$, so here the contributions are <<comma_and(contribs)>>\n    - The chi-square test statistic is the sum of all the contributions, so $\\chi^2 = <<glue_collapse(contribs, sep=\"+\")>> = <<chisq>>$.)\",\n    r\"(Degrees of Freedom: $df = k - 1 = <<k>> - 1 = <<df>>$)\",\n    r\"(p-value: `pchisq(<<chisq>>, df=<<df>>, lower.tail=FALSE)` = <<pval>>)\",\n    r\"(Formal Decision: We see that $p = <<pval>> <<comp(pval, alpha)>> <<alpha>> = \\alpha$, so we <<ht_result>> the null hypothesis)\",\n    r\"(Interpretation: We<<donot>> have enough evidence to conclude that <<topic>>.)\"\n  )\n  \n  tables = with(setup, list(obs_tab))\n  \n  return(lst(\n    setup,\n    question = compile_text(question_template, setup),\n    subquestions = sapply(subquestion_templates, function(x) {compile_text(x, setup)}),\n    subsolutions = sapply(subsolution_templates, function(x) {compile_text(x, setup)}),\n    tables\n  ))\n}\n\n# TODO: Chi-square goodness of fit for unequal proportions\n\n# TODO: Chi-square test for association\n\n# TODO: ANOVA test\n","type":"text"}]
